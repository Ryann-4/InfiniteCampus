<html lang="en">
<head>
    <title>Infinite Campus</title>
    <meta charset="UTF-8">
    <style>
        #toolbar {
            margin: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        #canvas {
            background-color: white;
            touch-action: none;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <label>Color:
            <input type="color" id="colorPicker" value="#000000">
        </label>
        <label>Brush Size:
            <input type="range" id="brushSize" min="1" max="50" value="5">
        </label>
        <button id="eraser">Eraser</button>
        <button id="clear">Clear</button>
        <input type="file" id="imageUpload" accept="image/*">
        <button id="cropBtn">Toggle Crop Mode</button>
        <button id="exportBtn">Export PNG</button>
    </div>
    <canvas id="canvas" width="1200" height="600"></canvas>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const colorPicker = document.getElementById("colorPicker");
        const brushSize = document.getElementById("brushSize");
        const eraserBtn = document.getElementById("eraser");
        const clearBtn = document.getElementById("clear");
        const imageUpload = document.getElementById("imageUpload");
        const cropBtn = document.getElementById("cropBtn");
        const exportBtn = document.getElementById("exportBtn");

        let drawing = false;
        let isErasing = false;
        let cropMode = false;
        let images = []; // store images with position/size/rotation
        let selectedImage = null;
        let offsetX, offsetY;

        // Load saved canvas state
        function loadCanvasState() {
            const saved = localStorage.getItem("canvasState");
            if (saved) {
                const img = new Image();
                img.src = saved;
                img.onload = () => ctx.drawImage(img, 0, 0);
            }
        }
        loadCanvasState();

        // Save state on changes
        function saveCanvasState() {
            localStorage.setItem("canvasState", canvas.toDataURL());
        }

        // Drawing functions
        canvas.addEventListener("mousedown", e => {
            const mousePos = { x: e.offsetX, y: e.offsetY };
            selectedImage = getImageAt(mousePos);
            if (selectedImage) {
                offsetX = mousePos.x - selectedImage.x;
                offsetY = mousePos.y - selectedImage.y;
            } else {
                drawing = true;
                ctx.beginPath();
                ctx.moveTo(e.offsetX, e.offsetY);
            }
        });

        canvas.addEventListener("mousemove", e => {
            if (selectedImage && !drawing) {
                selectedImage.x = e.offsetX - offsetX;
                selectedImage.y = e.offsetY - offsetY;
                redrawCanvas();
            } else if (drawing) {
                ctx.lineWidth = brushSize.value;
                ctx.lineCap = "round";
                ctx.strokeStyle = isErasing ? "#ffffff" : colorPicker.value;
                ctx.lineTo(e.offsetX, e.offsetY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(e.offsetX, e.offsetY);
            }
        });

        canvas.addEventListener("mouseup", () => {
            drawing = false;
            selectedImage = null;
            saveCanvasState();
        });

        function getImageAt(pos) {
            return images.find(img =>
                pos.x >= img.x &&
                pos.x <= img.x + img.width &&
                pos.y >= img.y &&
                pos.y <= img.y + img.height
            );
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            images.forEach(img => {
                ctx.save();
                ctx.translate(img.x + img.width / 2, img.y + img.height / 2);
                ctx.rotate(img.rotation * Math.PI / 180);
                ctx.drawImage(img.image, -img.width / 2, -img.height / 2, img.width, img.height);
                ctx.restore();
            });
            saveCanvasState();
        }

        // Upload image
        imageUpload.addEventListener("change", e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                const img = new Image();
                img.src = reader.result;
                img.onload = () => {
                    images.push({
                        image: img,
                        x: 100,
                        y: 100,
                        width: img.width / 2,
                        height: img.height / 2,
                        rotation: 0
                    });
                    redrawCanvas();
                };
            };
            reader.readAsDataURL(file);
        });

        // Buttons
        eraserBtn.addEventListener("click", () => {
            isErasing = !isErasing;
            eraserBtn.textContent = isErasing ? "Drawing Mode" : "Eraser";
        });

        clearBtn.addEventListener("click", () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            images = [];
            localStorage.removeItem("canvasState");
        });

        cropBtn.addEventListener("click", () => {
            cropMode = !cropMode;
            cropBtn.textContent = cropMode ? "Exit Crop Mode" : "Toggle Crop Mode";
            // You can add crop functionality here
        });

        exportBtn.addEventListener("click", () => {
            const link = document.createElement("a");
            link.download = "canvas.png";
            link.href = canvas.toDataURL();
            link.click();
        });
    </script>
</body>
</html>
