<html>
    <head>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-7SV03ZXJ9R">
        </script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-7SV03ZXJ9R');
        </script>
        <title>
            Infinite Campus
        </title>
        <link id="dynamic-favicon" rel="icon" type="image/png" href="https://codehs.com/uploads/f111a37947de2cea81db858094c04f2d">
        <link rel="stylesheet" href="global.css">
        <meta name="keywords" content="Infinite campus,infinite campus,Infinite Campus,infinite Campus">
        <meta name="description" content="Infinite Campus Is A International Buisiness And Has Good Devs">
        <meta property="og:title" content="Infinite Campus">
        <meta property="og:description" content="Infinite Campus Is An International Buisiness And Has Good Devs">
        <meta property="og:url" content="https://ryann-4.github.io/InfiniteCampus/">
        <meta name="theme-color" content="#8cbe37">
        <meta content="https://codehs.com/uploads/30883de2def50482be6e6fb25ea68477" property="og:image">
        <script src="main.js">
        </script>
        <script src="drypopup.js">
        </script>
        <script src="theme.js">
        </script>
        <style>
            :root {
                --bg: #0b0e14;
                --panel: #131722;
                --text: #e8ecf1;
                --muted: #9aa4b2;
                --accent: #4c9aff;
                --accent-2: #7c4cff;
                --border: #232838;
                --danger: #ff6565;
                --radius: 14px;
                --shadow: 0 10px 30px rgba(0,0,0,.35);
            }
            * { 
                box-sizing: border-box 
            }
            .wrap { 
                max-width: 980px; 
                margin: 32px auto; 
                padding: 0 16px; 
            }
            .topbar {
                display:flex; 
                gap:14px; 
                align-items:center; 
                justify-content:space-between; 
                margin-bottom:16px;
            }
            .filebox {
                display:flex; 
                align-items:center; 
                gap:10px; 
                background:var(--panel); 
                border:1px solid var(--border);
                padding:10px 12px; 
                border-radius: var(--radius);
            }
            input[type="file"] {
                appearance: none; 
                background:#0f1320; 
                border:1px dashed var(--border); 
                color:var(--muted);
                padding:8px 10px; 
                border-radius:10px; 
                width:100%;
            }
            .hint { 
                color: var(--muted); 
                font-size: 12px; 
            }
            .player {
                background: var(--panel); 
                border: 1px solid var(--border); 
                border-radius: var(--radius);
                padding: 16px; 
                box-shadow: var(--shadow);
            }
            .now {
                display:flex; 
                gap:16px; 
                align-items:center; 
                margin-bottom: 14px;
            }
            .art {
                width: 110px; 
                height:110px; 
                flex: 0 0 110px; 
                border-radius: 12px; 
                overflow:hidden; 
                background:#0f1320; 
                border:1px solid var(--border);
            }
            .art img { 
                width:100%; 
                height:100%; 
                object-fit:cover; 
                display:block; 
            }
            .nowtext { 
                flex:1 1 auto; 
                min-width:0; 
            }
            .nowtext h2 { 
                margin:0; 
                font-size:16px; 
                color:var(--muted); 
                font-weight:600; 
                letter-spacing:.3px; 
            }
            .nowtext h3 { 
                margin:6px 0 0; 
                font-size:22px; 
                white-space:nowrap; 
                overflow:hidden; 
                text-overflow:ellipsis; 
            }
            .controls {
                display:grid; 
                grid-template-columns: 1fr auto auto auto auto; 
                gap:12px; 
                align-items:center; 
                margin-top: 10px;
            }
            .progress {
                display:flex; 
                align-items:center; 
                gap:10px;
            }
            .time { 
                width:90px; 
                text-align:right; 
                font-variant-numeric: tabular-nums; 
                color:var(--muted); 
            }
            input[type="range"] {
                width:100%;
                appearance:none; 
                height:6px; 
                border-radius:999px; 
                background:#0f1320; 
                outline:none; 
                border:1px solid var(--border);
            }
            input[type="range"]::-webkit-slider-thumb { 
                appearance:none; 
                width:14px; 
                height:14px; 
                border-radius:50%; 
                background:var(--accent); 
                cursor:pointer; 
            }
            input[type="range"]::-moz-range-thumb { 
                width:14px; 
                height:14px; 
                border-radius:50%; 
                background:var(--accent); 
                border:none; 
                cursor:pointer; 
            }
            .btn {
                appearance:none; 
                border:none; 
                background:#0f1320; 
                border:1px solid var(--border);
                color:var(--text); 
                padding:10px 12px; 
                border-radius:12px; 
                cursor:pointer;
            }
            .btn:hover { 
                border-color:#2b3043; 
            }
            .btn:active { 
                transform: translateY(1px); 
            }
            .btn.toggled { 
                outline: 2px solid var(--accent); 
            }
            .listwrap {
                margin-top: 16px; 
                border:1px dashed var(--border); 
                border-radius: var(--radius);
                padding: 10px;
            }
            .headerline {
                display:flex; 
                justify-content:space-between; 
                align-items:center; 
                color:var(--muted); 
                font-size:13px; 
                padding:0 6px 8px;
            }
            .playlist {
                list-style:none; 
                margin:0; 
                padding:0; 
                display:flex; 
                flex-direction:column; 
                gap:8px;
            }
            .track {
                display:flex; 
                align-items:center; 
                gap:12px; 
                padding:10px; 
                background:#0f1320; 
                border:1px solid var(--border);
                border-radius:12px;
            }
            .drag-handle { 
                cursor:grab;
                user-select:none; 
                opacity:.9; 
            }
            .index { 
                width:28px; 
                text-align:right; 
                color:var(--muted); 
                font-variant-numeric: tabular-nums; 
            }
            .track-title { 
                flex:1 1 auto; 
                white-space:nowrap; 
                overflow:hidden; 
                text-overflow:ellipsis; 
            }
            .track.active { 
                border-color: var(--accent); 
                background: linear-gradient(0deg, rgba(76,154,255,.06), rgba(76,154,255,.06)), #0f1320; 
            }
            .ghost { 
                opacity:.4; 
            }
            .hidden { 
                display:none !important; 
            }
            .floating {
                position: fixed; 
                right: 24px; 
                bottom: 24px; 
                width: 320px; 
                border-radius: 16px; 
                overflow: hidden;
                border:1px solid rgba(255,255,255,.15); 
                box-shadow: var(--shadow); 
                backdrop-filter: blur(6px);
                background: #1116;
            }
            .floating-bg {
                position:absolute; 
                inset:0; 
                background-size:cover; 
                background-position:center; 
                filter: blur(2px);
                transform: scale(1.05);
            }
            .floating-content {
                position: relative; 
                padding: 12px; 
                color: #fff;
            }
            .floating-top {
                display:flex; 
                justify-content:space-between; 
                align-items:center; 
                gap:8px;
                cursor: move; 
                user-select:none;
            }
            .floating-title { 
                font-size:14px; 
                font-weight:600; 
                white-space:nowrap; 
                overflow:hidden; 
                text-overflow:ellipsis; 
            }
            .closex {
                appearance:none; 
                border:none; 
                background: #0008; 
                color:#fff; 
                width:28px; 
                height:28px; 
                border-radius:10px; 
                cursor:pointer;
            }
            .floating-progress { 
                margin-top:10px; 
                display:flex; 
                align-items:center; 
                gap:8px; 
            }
            .floating-controls { 
                margin-top:10px; 
                display:flex; 
                gap:8px; 
            }
            .floating input[type="range"] { 
                background:#ffffff33; 
                border-color:#ffffff55; 
            }
            .floating .btn { 
                background:#0007; 
                border-color:#ffffff33; 
                color:#fff; 
            }
            .footer {
                margin-top: 14px; 
                display:flex; 
                justify-content:space-between; 
                align-items:center; 
                color:var(--muted); 
                font-size:12px;
            }
            @media (max-width: 640px) {
                .now { flex-direction: column; align-items:flex-start; }
                .controls { grid-template-columns: 1fr 1fr 1fr 1fr; }
                .time { display:none; }
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="topbar">
                <div class="filebox" title="Add up to 20 audio files">
                    <strong>
                        Upload Files
                    </strong>
                    <input id="fileInput" type="file" accept="audio/*" multiple />
                </div>
                <div class="hint">
                    Drag to reorder • Auto-saves to IndexedDB • Max 20 files
                </div>
            </div>
            <section class="player">
                <div class="now">
                    <div class="art">
                        <img id="artImg" alt="Artwork" />
                    </div>
                    <div class="nowtext">
                        <h2>
                            Now Playing:
                        </h2>
                        <h3 id="nowTitle">–</h3>
                        <div class="controls">
                            <div class="progress">
                                <input id="seek" type="range" min="0" max="1000" value="0" step="1" />
                                <div class="time">
                                    <span id="curTime">
                                        0:00
                                    </span>
                                     / 
                                    <span id="durTime">
                                        0:00
                                    </span>
                                </div>
                            </div>
                            <button class="button" id="btnPrev" title="Previous (or restart)">
                                &laquo;
                            </button>
                            <button class="button" id="btnPlay">
                                ▶
                            </button>
                            <button class="button" id="btnNext" title="Next">
                                &raquo;
                            </button>
                            <button class="button" id="btnLoop" title="Loop playlist">
                                Loop
                            </button>
                        </div>
                    </div>
                </div>
                <div class="listwrap">
                    <div class="headerline">
                        <div>
                            <strong>
                                Playlist
                            </strong>
                        </div>
                        <div id="countInfo">
                            0 Tracks
                        </div>
                    </div>
                    <ul id="playlist" class="playlist" aria-label="Playlist (draggable)"></ul>
                </div>
                <div class="footer">
                    <div>
                        Tip: Use browser media keys to control playback.
                    </div>
                    <div id="saveStatus">
                        Not saved
                    </div>
                </div>
            </section>
        </div>
        <div class="floating hidden" id="floating">
            <div class="floating-bg" id="floatingBg">
            </div>
            <div class="floating-content">
                <div class="floating-top" id="floatingDragHandle">
                    <div class="floating-title" id="floatingTitle">
                        Now Playing
                    </div>
                    <button class="closex" id="floatingClose" aria-label="Close">
                        ✕
                    </button>
                </div>
                <div class="floating-progress">
                    <input id="seekMini" type="range" min="0" max="1000" value="0" step="1" />
                    <div class="time" id="miniTimes">
                        0:00 / 0:00
                    </div>
                </div>
                <div class="floating-controls">
                    <button class="button" id="miniPrev">
                        &laquo;
                    </button>
                    <button class="button" id="miniPlay">
                        Play
                    </button>
                    <button class="button" id="miniNext">
                        &raquo;
                    </button>
                    <button class="button" id="miniLoop">
                        Loop
                    </button>
                </div>
            </div>
        </div>
        <audio id="audio" preload="metadata" crossorigin="anonymous"></audio>
<script>
/* ==========================
   CONFIG & GLOBALS
========================== */
const FALLBACK_ART = "https://codehs.com/uploads/f111a37947de2cea81db858094c04f2d";
const MAX_FILES = 20;
const PREV_RESTART_THRESHOLD = 10; // seconds

// IndexedDB setup
const DB_NAME = "dryPlayerDB";
const DB_VERSION = 1;
let db;

// App state (mirrored in DB)
let tracks = []; // array of { id, title, blob, artworkDataUrl, position }
let currentIndex = 0;
let isLooping = false;
let isLoadedFromDB = false;

const els = {
  fileInput: document.getElementById('fileInput'),
  playlist: document.getElementById('playlist'),
  nowTitle: document.getElementById('nowTitle'),
  artImg: document.getElementById('artImg'),
  audio: document.getElementById('audio'),
  seek: document.getElementById('seek'),
  curTime: document.getElementById('curTime'),
  durTime: document.getElementById('durTime'),
  btnPrev: document.getElementById('btnPrev'),
  btnPlay: document.getElementById('btnPlay'),
  btnNext: document.getElementById('btnNext'),
  btnLoop: document.getElementById('btnLoop'),
  countInfo: document.getElementById('countInfo'),
  saveStatus: document.getElementById('saveStatus'),
  // floating
  floating: document.getElementById('floating'),
  floatingBg: document.getElementById('floatingBg'),
  floatingTitle: document.getElementById('floatingTitle'),
  floatingClose: document.getElementById('floatingClose'),
  floatingDragHandle: document.getElementById('floatingDragHandle'),
  seekMini: document.getElementById('seekMini'),
  miniTimes: document.getElementById('miniTimes'),
  miniPrev: document.getElementById('miniPrev'),
  miniPlay: document.getElementById('miniPlay'),
  miniNext: document.getElementById('miniNext'),
  miniLoop: document.getElementById('miniLoop'),
};

// Utility: time formatting
function fmtTime(s) {
  s = Math.max(0, Math.floor(s || 0));
  const m = Math.floor(s / 60);
  const r = s % 60;
  return m + ":" + String(r).padStart(2, '0');
}

// Utility: trim extension from filename
function stripExt(name) {
  const dot = name.lastIndexOf('.');
  return dot > 0 ? name.slice(0, dot) : name;
}

// ----- IndexedDB -----
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      db = e.target.result;
      if (!db.objectStoreNames.contains('songs')) {
        const store = db.createObjectStore('songs', { keyPath: 'id', autoIncrement: true });
        store.createIndex('position', 'position', { unique: false });
      }
      if (!db.objectStoreNames.contains('state')) {
        db.createObjectStore('state', { keyPath: 'key' });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e);
  });
}

function saveAll() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['songs','state'], 'readwrite');
    const songsStore = tx.objectStore('songs');
    const stateStore = tx.objectStore('state');

    // Clear and re-put all songs to keep positions updated
    const clearReq = songsStore.clear();
    clearReq.onsuccess = () => {
      let pending = tracks.length;
      if (pending === 0) {
        // still save state
        stateStore.put({ key:'currentIndex', value: currentIndex });
        stateStore.put({ key:'isLooping', value: isLooping });
        resolve();
        return;
      }
      tracks.forEach(t => {
        const putReq = songsStore.put({
          id: t.id ?? undefined,
          title: t.title,
          blob: t.blob,
          artworkDataUrl: t.artworkDataUrl,
          position: t.position
        });
        putReq.onsuccess = () => { if (--pending === 0) {
          stateStore.put({ key:'currentIndex', value: currentIndex });
          stateStore.put({ key:'isLooping', value: isLooping });
          resolve();
        }};
        putReq.onerror = (e) => reject(e);
      });
    };
    clearReq.onerror = (e) => reject(e);
  }).then(() => showSaved('Saved')).catch(()=> showSaved('Save failed', true));
}

function loadAll() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['songs','state'], 'readonly');
    const songsStore = tx.objectStore('songs');
    const idx = songsStore.index('position');
    const tracksOut = [];
    idx.openCursor(null, 'next').onsuccess = (e) => {
      const cursor = e.target.result;
      if (cursor) {
        const v = cursor.value;
        tracksOut.push({ id: v.id, title: v.title, blob: v.blob, artworkDataUrl: v.artworkDataUrl, position: v.position });
        cursor.continue();
      } else {
        const stateStore = tx.objectStore('state');
        const getCur = stateStore.get('currentIndex');
        const getLoop = stateStore.get('isLooping');
        getCur.onsuccess = () => {
          getLoop.onsuccess = () => {
            resolve({
              tracks: tracksOut,
              currentIndex: getCur.result?.value ?? 0,
              isLooping: !!(getLoop.result?.value)
            });
          };
        };
      }
    };
    idx.openCursor().onerror = reject;
  });
}

function showSaved(msg, error=false) {
  els.saveStatus.textContent = msg;
  els.saveStatus.style.color = error ? 'var(--danger)' : 'var(--muted)';
  setTimeout(() => { els.saveStatus.textContent = " "; }, 1800);
}

// ----- Artwork extraction (basic ID3v2 APIC support) -----
async function extractArtworkDataUrl(file) {
  try {
    // Read first 256KB (usually enough to include ID3v2 header & APIC)
    const head = await file.slice(0, 262144).arrayBuffer();
    const view = new DataView(head);
    // Check ID3v2
    if (String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2)) !== 'ID3') {
      return FALLBACK_ART;
    }
    const version = view.getUint8(3); // 3 or 4 usually
    const flags = view.getUint8(5);
    const size = ((view.getUint8(6) & 0x7f) << 21) | ((view.getUint8(7) & 0x7f) << 14) |
                 ((view.getUint8(8) & 0x7f) << 7)  |  (view.getUint8(9) & 0x7f);
    let offset = 10;
    if (flags & 0x40) {
      // extended header present — skip it (v2.3/2.4)
      const extSize = version === 4
        ? ((view.getUint8(offset) & 0x7f) << 21) | ((view.getUint8(offset+1) & 0x7f) << 14) |
          ((view.getUint8(offset+2) & 0x7f) << 7) | (view.getUint8(offset+3) & 0x7f)
        : view.getUint32(offset);
      offset += extSize + 4;
    }
    while (offset + 10 <= head.byteLength) {
      const fid = String.fromCharCode(
        view.getUint8(offset+0),
        view.getUint8(offset+1),
        view.getUint8(offset+2),
        view.getUint8(offset+3)
      );
      let fsize = version === 4
        ? ((view.getUint8(offset+4) & 0x7f) << 21) | ((view.getUint8(offset+5) & 0x7f) << 14) |
          ((view.getUint8(offset+6) & 0x7f) << 7)  |  (view.getUint8(offset+7) & 0x7f)
        : view.getUint32(offset+4);
      const fflags = view.getUint16(offset+8);
      offset += 10;
      if (!fid.trim() || fsize <= 0) break;
      if (fid === 'APIC' && offset + fsize <= head.byteLength) {
        const apic = new Uint8Array(head, offset, fsize);
        let p = 0;
        const textEnc = apic[p++]; // 0: ISO-8859-1, 1: UTF16, 3: UTF8 (we don't need it)
        // MIME type: ascii until 0x00
        let mimeEnd = p;
        while (mimeEnd < apic.length && apic[mimeEnd] !== 0) mimeEnd++;
        const mime = new TextDecoder('iso-8859-1').decode(apic.subarray(p, mimeEnd)) || 'image/jpeg';
        p = mimeEnd + 1;
        p += 1; // picture type byte
        // Description (encoding-dependent) until 0x00 (or 0x00 0x00 for UTF16)
        if (textEnc === 1) {
          // UTF-16, skip until double 0
          while (p+1 < apic.length && !(apic[p]===0 && apic[p+1]===0)) p+=2;
          p+=2;
        } else {
          while (p < apic.length && apic[p] !== 0) p++;
          p++;
        }
        const imgBytes = apic.subarray(p);
        const blob = new Blob([imgBytes], { type: mime || 'image/jpeg' });
        const dataUrl = await blobToDataURL(blob);
        return dataUrl || FALLBACK_ART;
      }
      offset += fsize;
    }
  } catch {}
  return FALLBACK_ART;
}
function blobToDataURL(blob) {
  return new Promise((resolve) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = () => resolve(null);
    fr.readAsDataURL(blob);
  });
}

// ----- Build UI -----
function refreshListUI() {
  els.playlist.innerHTML = '';
  tracks.sort((a,b) => a.position - b.position);
  tracks.forEach((t, i) => {
    const li = document.createElement('li');
    li.className = 'track' + (i === currentIndex ? ' active' : '');
    li.draggable = true;
    li.dataset.id = t.id;
    li.innerHTML = `
      <span class="drag-handle" title="Drag">☰</span>
      <span class="index">${i+1}</span>
      <span class="track-title" title="${t.title}">${t.title}</span>
    `;
    li.addEventListener('click', () => {
      if (currentIndex !== i) {
        currentIndex = i;
        loadCurrentTrack(true);
      }
    });
    addDragHandlers(li);
    els.playlist.appendChild(li);
  });
  els.countInfo.textContent = `${tracks.length} track${tracks.length===1?'':'s'}`;
}

function setNowPlayingUI() {
  const t = tracks[currentIndex];
  if (!t) {
    els.nowTitle.textContent = '–';
    els.artImg.src = FALLBACK_ART;
    return;
  }
  els.nowTitle.textContent = t.title || 'Untitled';
  els.artImg.src = t.artworkDataUrl || FALLBACK_ART;

  // floating
  els.floatingTitle.textContent = t.title || 'Untitled';
  els.floatingBg.style.backgroundImage = `url("${(t.artworkDataUrl || FALLBACK_ART).replace(/"/g,'\\"')}")`;

  // Media Session
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title: t.title || 'Untitled',
      artist: '',
      album: 'Playlist',
      artwork: [
        { src: t.artworkDataUrl || FALLBACK_ART, sizes: '512x512', type: 'image/png' }
      ]
    });
  }
}

function setLoopUI() {
  els.btnLoop.classList.toggle('toggled', isLooping);
  els.miniLoop.classList.toggle('toggled', isLooping);
}

// ----- Audio handling -----
let objectUrlCache = new Map(); // id -> objectURL to revoke later

function getObjectURLForTrack(t) {
  if (objectUrlCache.has(t.id)) return objectUrlCache.get(t.id);
  const url = URL.createObjectURL(t.blob);
  objectUrlCache.set(t.id, url);
  return url;
}
function revokeAllObjectURLs() {
  for (const url of objectUrlCache.values()) URL.revokeObjectURL(url);
  objectUrlCache.clear();
}

function loadCurrentTrack(autoplay=false, keepTime=false) {
  const t = tracks[currentIndex];
  if (!t) return;
  // Update UI selection
  [...els.playlist.children].forEach((li, i) => li.classList.toggle('active', i === currentIndex));

  setNowPlayingUI();

  const url = getObjectURLForTrack(t);
  const wasPlaying = !els.audio.paused;
  const prevTime = els.audio.currentTime || 0;

  els.audio.src = url;
  if (keepTime) els.audio.currentTime = prevTime;

  if (autoplay || wasPlaying) {
    els.audio.play().catch(()=>{});
    setPlayButtons(true);
  } else {
    setPlayButtons(false);
  }
  saveAll();
}

function setPlayButtons(playing) {
  els.btnPlay.textContent = playing ? 'Pause' : 'Play';
  els.miniPlay.textContent = playing ? 'Pause' : 'Play';
}

function nextTrack(autoplay=true) {
  if (tracks.length === 0) return;
  if (currentIndex < tracks.length - 1) {
    currentIndex++;
    loadCurrentTrack(autoplay);
  } else {
    if (isLooping) {
      currentIndex = 0;
      loadCurrentTrack(true);
    } else {
      // stop at end
      els.audio.pause();
      els.audio.currentTime = 0;
      setPlayButtons(false);
    }
  }
}

function prevTrackSmart() {
  if (tracks.length === 0) return;
  if (els.audio.currentTime > PREV_RESTART_THRESHOLD) {
    els.audio.currentTime = 0;
  } else {
    if (currentIndex > 0) {
      currentIndex--;
      loadCurrentTrack(true);
    } else {
      // at start
      if (isLooping) {
        currentIndex = tracks.length - 1;
        loadCurrentTrack(true);
      } else {
        els.audio.currentTime = 0;
      }
    }
  }
}

// ----- Drag & drop sorting -----
let dragSrcEl = null;
function addDragHandlers(li) {
  li.addEventListener('dragstart', (e) => {
    dragSrcEl = li;
    li.classList.add('ghost');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', li.dataset.id);
  });
  li.addEventListener('dragend', () => {
    dragSrcEl = null;
    li.classList.remove('ghost');
  });
  li.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  });
  li.addEventListener('drop', (e) => {
    e.preventDefault();
    const fromId = e.dataTransfer.getData('text/plain');
    const toId = li.dataset.id;
    if (fromId === toId) return;
    const fromIdx = tracks.findIndex(t => String(t.id) === String(fromId));
    const toIdx = tracks.findIndex(t => String(t.id) === String(toId));
    if (fromIdx === -1 || toIdx === -1) return;

    // Reorder array by moving item
    const [moved] = tracks.splice(fromIdx, 1);
    tracks.splice(toIdx, 0, moved);

    // Reassign positions
    tracks.forEach((t,i)=> t.position = i);

    // Update currentIndex to new index of the active track
    if (currentIndex === fromIdx) currentIndex = toIdx;
    else if (fromIdx < currentIndex && toIdx >= currentIndex) currentIndex--;
    else if (fromIdx > currentIndex && toIdx <= currentIndex) currentIndex++;

    refreshListUI();
    saveAll();
  });
}

// ----- Floating mini-player behaviors -----
(function makeFloatingDraggable() {
  const dragHandle = els.floatingDragHandle;
  const floating = els.floating;
  let startX=0, startY=0, originX=0, originY=0, dragging=false;

  function onDown(e) {
    dragging = true;
    const rect = floating.getBoundingClientRect();
    originX = rect.left;
    originY = rect.top;
    startX = e.clientX;
    startY = e.clientY;
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  }
  function onMove(e) {
    if (!dragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    floating.style.left = (originX + dx) + 'px';
    floating.style.top = (originY + dy) + 'px';
    floating.style.right = 'auto';
    floating.style.bottom = 'auto';
  }
  function onUp() {
    dragging = false;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
  }
  dragHandle.addEventListener('mousedown', onDown);
})();

// ----- Media Session integration -----
if ('mediaSession' in navigator) {
  navigator.mediaSession.setActionHandler('play', async () => { await els.audio.play().catch(()=>{}); setPlayButtons(true); });
  navigator.mediaSession.setActionHandler('pause', () => { els.audio.pause(); setPlayButtons(false); });
  navigator.mediaSession.setActionHandler('previoustrack', () => prevTrackSmart());
  navigator.mediaSession.setActionHandler('nexttrack', () => nextTrack(true));
  navigator.mediaSession.setActionHandler('seekto', (details) => {
    if (details.fastSeek && 'fastSeek' in els.audio) {
      els.audio.fastSeek(details.seekTime);
    } else {
      els.audio.currentTime = details.seekTime ?? els.audio.currentTime;
    }
  });
  navigator.mediaSession.setActionHandler('seekbackward', (details) => {
    const step = details.seekOffset || 10;
    els.audio.currentTime = Math.max(0, els.audio.currentTime - step);
  });
  navigator.mediaSession.setActionHandler('seekforward', (details) => {
    const step = details.seekOffset || 10;
    els.audio.currentTime = Math.min(els.audio.duration || Infinity, els.audio.currentTime + step);
  });
}

// ----- Wire up UI events -----
els.fileInput.addEventListener('change', async (e) => {
  const files = Array.from(e.target.files || []).filter(f => f.type.startsWith('audio/'));
  if (files.length === 0) return;

  const allowed = Math.max(0, MAX_FILES - tracks.length);
  const toAdd = files.slice(0, allowed);
  if (toAdd.length < files.length) {
    alert(`Only ${allowed} more file(s) allowed (max ${MAX_FILES}).`);
  }

  // Load artwork + create blobs
  for (let i=0;i<toAdd.length;i++) {
    const f = toAdd[i];
    const artworkDataUrl = await extractArtworkDataUrl(f);
    const blob = new Blob([await f.arrayBuffer()], { type: f.type || 'audio/mpeg' });
    const title = stripExt(f.name);
    const position = tracks.length + i;
    tracks.push({ id: crypto.randomUUID(), title, blob, artworkDataUrl, position });
  }
  refreshListUI();
  if (tracks.length > 0) {
    if (els.floating.classList.contains('hidden')) {
      els.floating.classList.remove('hidden'); // show mini-player when playlist exists
    }
    if (tracks.length === toAdd.length) currentIndex = 0; // first time
    loadCurrentTrack(false);
  }
  await saveAll();
  // Clear file input so same files can be selected again later
  e.target.value = '';
});

els.btnPlay.addEventListener('click', async () => {
  if (els.audio.paused) { await els.audio.play().catch(()=>{}); setPlayButtons(true); }
  else { els.audio.pause(); setPlayButtons(false); }
});
els.btnNext.addEventListener('click', () => nextTrack(true));
els.btnPrev.addEventListener('click', () => prevTrackSmart());

els.btnLoop.addEventListener('click', () => { isLooping = !isLooping; setLoopUI(); saveAll(); });

// Seek bar & time updates
function syncSeekers() {
  const cur = els.audio.currentTime || 0;
  const dur = isFinite(els.audio.duration) ? (els.audio.duration || 0) : 0;
  const ratio = dur ? (cur / dur) : 0;
  const val = Math.round(ratio * 1000);
  els.seek.value = String(val);
  els.curTime.textContent = fmtTime(cur);
  els.durTime.textContent = fmtTime(dur);
  // mini
  els.seekMini.value = String(val);
  els.miniTimes.textContent = fmtTime(cur) + " / " + fmtTime(dur);
}
els.seek.addEventListener('input', () => {
  const dur = els.audio.duration || 0;
  els.audio.currentTime = +els.seek.value / 1000 * dur;
});
els.seekMini.addEventListener('input', () => {
  const dur = els.audio.duration || 0;
  els.audio.currentTime = +els.seekMini.value / 1000 * dur;
});

els.audio.addEventListener('timeupdate', syncSeekers);
els.audio.addEventListener('loadedmetadata', syncSeekers);
els.audio.addEventListener('durationchange', syncSeekers);
els.audio.addEventListener('ended', () => nextTrack(true));

// Floating controls mirror
els.miniPlay.addEventListener('click', async () => {
  if (els.audio.paused) { await els.audio.play().catch(()=>{}); setPlayButtons(true); }
  else { els.audio.pause(); setPlayButtons(false); }
});
els.miniPrev.addEventListener('click', () => prevTrackSmart());
els.miniNext.addEventListener('click', () => nextTrack(true));
els.miniLoop.addEventListener('click', () => { isLooping = !isLooping; setLoopUI(); saveAll(); });
els.floatingClose.addEventListener('click', () => {
  els.audio.pause();
  setPlayButtons(false);
  els.floating.classList.add('hidden');
});

// Keyboard shortcuts (space to play/pause)
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && !/INPUT|TEXTAREA|SELECT/.test(document.activeElement.tagName)) {
    e.preventDefault();
    if (els.audio.paused) els.audio.play().then(()=> setPlayButtons(true));
    else { els.audio.pause(); setPlayButtons(false); }
  }
});

// ----- Init -----
(async function init() {
  await openDB();
  const data = await loadAll();
  tracks = (data.tracks || []).map((t,i)=>({
    ...t,
    // Ensure position continuity
    position: Number.isFinite(t.position) ? t.position : i
  }));
  currentIndex = Math.min(Math.max(0, data.currentIndex || 0), Math.max(0, tracks.length-1));
  isLooping = !!data.isLooping;
  isLoadedFromDB = tracks.length > 0;

  refreshListUI();
  setLoopUI();

  if (tracks.length > 0) {
    els.floating.classList.remove('hidden');
    loadCurrentTrack(false);
  } else {
    // Set default visuals
    els.artImg.src = FALLBACK_ART;
  }
})();

// Cleanup object URLs when unloading
window.addEventListener('beforeunload', () => {
  revokeAllObjectURLs();
});
</script>
</body>
</html>
